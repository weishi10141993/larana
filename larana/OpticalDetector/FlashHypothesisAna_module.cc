////////////////////////////////////////////////////////////////////////
// Class:       FlashHypothesisAna
// Module Type: analyzer
// File:        FlashHypothesisAna_module.cc
//
// Generated at Mon Jan 19 18:46:10 2015 by Wesley Ketchum using artmod
// from cetpkgsupport v1_08_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "fhiclcpp/ParameterSet.h"

#include "art_root_io/TFileService.h"

#include "FlashHypothesisAnaAlg.h"

#include "larana/OpticalDetector/OpDigiProperties.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/ServicePack.h" // lar::extractProviders()
#include "larsim/PhotonPropagation/PhotonVisibilityService.h"

#include "TH1F.h"
#include "TTree.h"

namespace opdet {
  class FlashHypothesisAna;
}

namespace opdet {

  class FlashHypothesisAna : public art::EDAnalyzer {
  public:
    explicit FlashHypothesisAna(fhicl::ParameterSet const& p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    FlashHypothesisAna(FlashHypothesisAna const&) = delete;
    FlashHypothesisAna(FlashHypothesisAna&&) = delete;
    FlashHypothesisAna& operator=(FlashHypothesisAna const&) = delete;
    FlashHypothesisAna& operator=(FlashHypothesisAna&&) = delete;

    // Required functions.
    void analyze(art::Event const& e) override;

    // Selected optional functions.
    void beginJob() override;

  private:
    std::string fMCTrackLabel;
    std::string fMCSimPhotonsLabel;

    FlashHypothesisAnaAlg fAlg;
  };

  FlashHypothesisAna::FlashHypothesisAna(fhicl::ParameterSet const& p)
    : EDAnalyzer(p)
    , fMCTrackLabel(p.get<std::string>("MCTrackLabel"))
    , fMCSimPhotonsLabel(p.get<std::string>("MCSimPhotonsLabel"))
    , fAlg(p.get<fhicl::ParameterSet>("FlashHypothesisAnaAlgParams"))
  {}

  void FlashHypothesisAna::analyze(art::Event const& e)
  {

    art::Handle<std::vector<sim::MCTrack>> mctrackHandle;
    e.getByLabel(fMCTrackLabel, mctrackHandle);
    std::vector<sim::MCTrack> const& mctrackVec(*mctrackHandle);

    art::Handle<std::vector<sim::SimPhotons>> simPhotonsHandle;
    e.getByLabel(fMCSimPhotonsLabel, simPhotonsHandle);
    std::vector<sim::SimPhotons> const& simPhotonsVec(*simPhotonsHandle);

    art::ServiceHandle<opdet::OpDigiProperties const> opdigiHandle;
    art::ServiceHandle<phot::PhotonVisibilityService const> pvsHandle;

    opdet::OpDigiProperties const& opdigi(*opdigiHandle);
    phot::PhotonVisibilityService const& pvs(*pvsHandle);

    fAlg.RunComparison((unsigned int)e.run(),
                       (unsigned int)e.id().event(),
                       mctrackVec,
                       simPhotonsVec,
                       lar::extractProviders<geo::Geometry, detinfo::LArPropertiesService>(),
                       opdigi,
                       pvs);
  }

  void FlashHypothesisAna::beginJob()
  {
    art::ServiceHandle<geo::Geometry const> geoHandle;
    geo::Geometry const& geo(*geoHandle);

    art::ServiceHandle<art::TFileService const> tfs;

    fAlg.SetOutputObjects(tfs->make<TTree>("ctree", "FlashHypothesisAnaTree"),
                          tfs->make<TH1F>(),
                          tfs->make<TH1F>(),
                          tfs->make<TH1F>(),
                          tfs->make<TH1F>(),
                          tfs->make<TH1F>(),
                          tfs->make<TH1F>(),
                          tfs->make<TH1F>(),
                          tfs->make<TH1F>(),
                          tfs->make<TH1F>(),
                          geo);
    fAlg.FillOpDetPositions(geo);
  }

}

DEFINE_ART_MODULE(opdet::FlashHypothesisAna)
